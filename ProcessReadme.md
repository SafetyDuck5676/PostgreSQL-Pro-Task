Мыслительный процесс задачи PostgreSQL Pro:

Когда я прочитал руководство по задаче, первое, о чем я сразу подумал, — как программа поймет, что ей делать? Дата изменения файла или же изменение MD5-хеша файла похоже на правду, но стало со временем понятно, что это не самый лучший путь. MD5 может быть неточным и иметь коллизии, а изменение даты не означает, что файл действительно изменился, его могли просто еще раз сохранить для других целей. В итоге лучший способ — проверить содержимое файла.

После чего я начал настраивать необходимые инструменты. PostgreSQL имеет схожий с MySQL синтаксис, но немного другие команды. Процесс установки, безусловно, намного проще чем в MySQL. Я настроил пользователя, к которому также подключена БД, которую я в итоге и использовал в своей программе. Пока я просто настроил БД и продвинулся дальше. Обязательно добавил _ "github.com/lib/pq", чтобы пользоваться языком PostgreSQL внутри программы.

Я заметил, что в приведенном мне примере задачи PostgreSQL Pro используется тип языка yml или yaml для конфигурационного файла. Я решил его и использовать, создав аналогичный файл конфигурации, изменив команды и настроив свои собственные пути к программам.

Затем я распланировал программу. Такие задачи лучше делать шаг за шагом и разбивать действия на функции, которые они должны выполнять. Функциями были: "connectdb, execute commands, getlocalfilecontent, contentdiffers, getlatestversion, savechangestodb, monitoring, checkchanges, readconfig, readdir, checkErr, logerr". Я настроил две проверки на ошибку, одна "убивает" программу если ошибка фатальна, другая - показывает мне ошибку и программу не останавливает. Я также пока добавил в программу информацию о БД, необходимую для подключения, параметры по типу "пароль" видно в коде. Позже я это исправлю.

Как бы я прочитал конфиг? Я изучал статьи и документацию, нашел способ прочитать файл yaml, используя сторонний пакет «gopkg.in/yaml.v3». С помощью команды прочтения файла, я добавляю полученную информацию в неупорядоченную "карту" массив. Указанный массив карт имеет теги yaml Path и Commands, чтобы программа могла определить, что читать, захватывать или писать. Все эти теги находятся в структуре типа Config. Конфигурация yaml пока имеет только один путь, но я заранее намерен сделать так, чтобы эта программа сразу следила за несколькими программами.

Раскинув мыслями, следующим шагом нужно было настроить реальную таблицу в БД. Команду было не так уж сложно найти и выполнить, но я, потратив немного времени, нашел правильный способ создания строки идентификатора с автоматическим приращением, он немного отличался от команды MySQL. Остальные функции заработали так как надо.

Как сделать так, чтобы программа выполняла команды? Найти нужную функцию было просто, проблема заключалась в том, что команда в конфиге представляет собой полную строку в том виде, каким вы бы ее использовали внутри терминала, для того чтобы выполнять команды из самой программы go, нужно в качестве первого аргумента, записать исполняемый по выбору файл, а уже второй аргумент - либо строка или список строк, которые являются аргументами для исполняемого файла. Поэтому мне нужно было разделить команду из файла конфигурации на несколько частей, которые затем я мог бы поместить в функцию выполнения в качестве исполняемого файла и аргументов. Он вернет ошибку и прекратит выполнение команд, если есть ошибка.

Как тогда в таком случае отслеживать файлы внутри пути? Что ж, чтобы отслеживать файлы, я использовал путь из конфигурации для чтения содержимого каталога, если это файл, он возвращал мне список имен файлов. Программа будет следить за этим.

Самое время подумать, как программа будет вставлять информации в базу данных. Проверим изменение файла, включая изменения даты и времени, это нужно для таблицы данных. Я немного заплутал и потерялся с синтаксисом вставки в таблицу PostgreSQL, поскольку PostgreSQL не понимает ключевое слово set в операторе вставки. Вместо этого я прикрепил значения по индексу, и в итоге все заработало.

Нужно проверить актуальность файла. Я ввожу запрос, который считывает значения и распечатывает их. Getlatest выбирает последнюю запись для файла по его имени и пути, эти два поля вместе позволяют идентифицировать файл. Одного имени файла будет недостаточно, так как имена файлов могут быть одинаковыми в разных проектах. Упорядочить по убыванию id, чтобы иметь последнюю версию. Ограничьте результат только одной записью.

Нам также нужно проверить содержимое файла в момент запуска, проверив путь, указанный в конфигурации, также проверив фактическое имя файла. Заполняем и возвращаем данные.

Если содержимое отличается, проверяем это через функции, то программа возвращает ответ правда или нет. Это в целом суммирует все это в функции мониторинга. Зацикляем это и выдаем любые возможные ошибки.

Позже я добавил еще одну папку для отслеживания, где будут проводиться тесты над выбранной программой, также добавив регулярные выражения, журнал логирования и env тип файла. Хоть моя программа и настроена таким образом, что нетрудно отслеживать несколько программ, я столкнулся с проблемой отсутствия зависимостей при попытке запустить тест вне папки. Тесту нужны внешние зависимые параметры, из чего я сделал вывод что и в других программах будут ошибки, если они будут использовать внешние параметры. Я нашел команду os, которая позволяет мне запустить команду для изменения каталогов на указанный путь в yaml. Таким образом, вам не нужно указывать путь в команде go test - достаточно просто показать путь до программы, трекер сам перейдет куда надо.

Позже я нашел способы применения регулярного выражения для чтения каталога. Программа исключает отслеживание таких вещей, как mod и sum, к примеру. Однако трекер включает в себя и regexp include, и, при желании, пользователь может самостоятельно добавлять или отключать элементы с помощью конфигурации. Программа готова как и для варианта с include regexp и вариантом exclude.

Ну и наконец я использовал функцию для записи в файл как ошибок, так и успешных операций, функцию log. Это очень полезно для отладки и отслеживания в реальном времени. Также добавил такую вещь как env, куда я добавил параметры для базы данных. Очень полезно для безопасности, нежели чем держать пароли внутри программы.
